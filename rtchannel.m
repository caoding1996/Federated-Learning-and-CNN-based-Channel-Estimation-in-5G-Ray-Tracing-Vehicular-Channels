function [hest] = rtchannel(txlat,txlon,rxlat,rxlon,numrt)
%% transmitter and receiver configuration
% The code assumes that both the transmitter and the receiver use rectangular arrays. 
% The array orientations are specified as a pair of values representing azimuth and elevation. Both angles are in degrees.
% transmitterPos = [22.303679238527735, 114.1680287601443];
% receiverPos = [22.303487984951616, 114.16807569085316];
fc = 28e9;                            % carrier frequency (Hz)
transmitterPos = [txlat, txlon];      % Lat, lon
txAntSize = [8 8];                    % number of rows and columns in rectangular array (base station)
txArrayOrientation = [-30 0].';       % azimuth (0 deg is East, 90 deg is North) and elevation (positive points upwards) in deg
receiverPos = [rxlat, rxlon];          % Lat, lon
rxAntSize = [8 8];                    % number of rows and columns in rectangular array (UE).
rxArrayOrientation = [180 45].';      % azimuth (0 deg is East, 90 deg is North) and elevation (positive points upwards)  in deg
reflectionsOrder = 1;                 % number of reflections for ray tracing analysis (0 for LOS)

% Bandwidth configuration, required to set the channel sampling rate and for perfect channel estimation

SCS = 15; % subcarrier spacing
NRB = 52; % number of resource blocks, 10 MHz bandwidth

%% Import and Visualize 3-D Environment with Buildings for Ray Tracing
% Launch Site Viewer with buildings in Hong Kong Tsim Sha Tsui.

if exist('viewer','var') && isvalid(viewer) % viewer handle exists and viewer window is open
    viewer.clearMap();
else
    viewer = siteviewer("Basemap","satellite","Buildings","osm_bbox.osm");    
end

% Create the transmitter and the receiver.
% Locate the transmitter and the receiver on the map.

transmitterSite = txsite("Name","Transmitter", ...
    "Latitude",transmitterPos(1),"Longitude",transmitterPos(2),...
    "AntennaAngle",txArrayOrientation(1:2),...
    "AntennaHeight",1,...  % in m
    "TransmitterFrequency",fc);

receiverSite = rxsite("Name","Receiver", ...
    "Latitude",receiverPos(1),"Longitude",receiverPos(2),...
    "AntennaHeight",1,... % in m
    "AntennaAngle",rxArrayOrientation(1:2));

% Visualize the location of the transmitter and the receiver.

transmitterSite.show();
receiverSite.show();

% Ray Tracing Analysis
% Perform ray tracing analysis using the shooting and bouncing rays (SBR) method. 
% The SBR method includes effects from surface reflections and diffractions but does not include effects from refraction or scattering.

pm = propagationModel("raytracing","Method","sbr","MaxNumReflections",reflectionsOrder);
rays = raytrace(transmitterSite,receiverSite,pm,"Type","pathloss");
plot(rays{1});

% From the obtained rays, get the times of arrival, the average path gains, and the angles of departure and arrival. 
% For simplicity, normalize the propagation delay so that the first path occurs at time 0 sec, corresponding to no delay. 
% Use the path loss to obtain the average path gains.

pathToAs = [rays{1}.PropagationDelay]-min([rays{1}.PropagationDelay]);  % Time of arrival of each ray (normalized to 0 sec)
avgPathGains  = -[rays{1}.PathLoss];                                    % Average path gains of each ray
pathAoDs = [rays{1}.AngleOfDeparture];                                  % AoD of each ray
pathAoAs = [rays{1}.AngleOfArrival];                                    % AoA of each ray
isLOS = any([rays{1}.LineOfSight]);                                     % Line of sight flag

%% Configure the 5G MIMO (CDL) channel model with the information generated by the ray tracing analysis.
% The ray tracer finds individual rays between the transmitter and the receiver, 
% while the CDL channel models clusters of rays whose properties are determined by the cluster average path gain (AveragePathGains), 
% average angles of arrival and departure (AnglesAoA, AnglesZoA, AnglesAoD, and AnglesZoD), 
% and the spread of the rays in the cluster (AngleSpreads). 
% The information retrieved from the ray tracing analysis for individual rays configures the cluster average values of the CDL channel.

channel = nrCDLChannel;
channel.DelayProfile = 'Custom';
channel.PathDelays = pathToAs;
channel.AveragePathGains = avgPathGains; % Average path loss of the ray tracing channel
channel.AnglesAoD = pathAoDs(1,:);       % azimuth of departure
channel.AnglesZoD = 90-pathAoDs(2,:);    % channel uses zenith angle, rays use elevation
channel.AnglesAoA = pathAoAs(1,:);       % azimuth of arrival
channel.AnglesZoA = 90-pathAoAs(2,:);    % channel uses zenith angle, rays use elevation
channel.HasLOSCluster = isLOS;
channel.CarrierFrequency = fc;
channel.NormalizeChannelOutputs = false; % do not normalize by the number of receive antennas, this would change the receive power
channel.NormalizePathGains = false;      % set to false to retain the path gains

% Specify the channel antenna arrays by using Phased Array System Toolbox array objects. 
% The array orientation properties of the CDL channel model use azimuth and downtilt while 
% the ueArrayOrientation and bsArrayOrientation objects use azimuth and elevation. 
% Therefore, convert the elevation to downtilt by changing the sign.
c = physconst('LightSpeed');
lambda = c/fc;
% rx array
rxArray = phased.URA('Size',rxAntSize(1:2),'ElementSpacing', 0.5*lambda*[1 1]);            % isotropic element by default
channel.ReceiveAntennaArray = rxArray;
channel.ReceiveArrayOrientation = [rxArrayOrientation(1); (-1)*rxArrayOrientation(2); 0];  % the (-1) converts elevation to downtilt
% tx array
txArray = phased.URA('Size',txAntSize(1:2),'ElementSpacing', 0.5*lambda*[1 1],'Element',phased.NRAntennaElement);
channel.TransmitAntennaArray = txArray;
channel.TransmitArrayOrientation = [txArrayOrientation(1); (-1)*txArrayOrientation(2); 0];   % the (-1) converts elevation to downtilt

% Set Channel Sampling Rate
% The signal going through the channel determines the channel sampling rate. 
% Consider a signal with subcarrier spacing of 15 kHz and 52 resource blocks (RBs), equivalent to a bandwidth of 10 MHz. 
% To obtain the sampling rate, call the nrOFDMInfo function.

ofdmInfo = nrOFDMInfo(NRB,SCS);
channel.SampleRate = ofdmInfo.SampleRate;

% Perform a perfect rt channel estimation as benchmark. 
% Setting the ChannelFiltering property to false allows us to get the channel path gains without sending a signal through the channel.

signalIn = rand(256,64);
channel.ChannelFiltering = true;
[signalOut,pathGains,sampleTimes] = channel(signalIn);
% save('InputSignal', 'signalIn')
% save('OutputSignal', 'signalOut')
% Plot the path gains returned by the channel.
% pg=permute(pathGains,[2 1 3 4]); % first dimension is the number of paths
% if isLOS
%     % in LOS cases sum the first to paths, they correspond to the LOS ray
%     pg = [sum(pg(1:2,:,:,:)); pg(3:end,:,:,:)];
% end
% pg = abs(pg).^2;
% plot(pow2db(pg(:,1,1,1)),'o-.');hold on
% plot(avgPathGains,'x-.');hold off
% legend("Instantaneous (1^{st} tx - 1^{st} rx antenna)","Average (from ray tracing)")
% xlabel("Path number"); ylabel("Gain (dB)")
% title('Path gains')

% Plot the channel response in time and frequency between the first transmit and the first receive antenna. 
% This plot shows how the channel behaves in time and frequency. For low Doppler shifts, 
% the channel doesn't change much during the observation period of one slot.
pathFilters = getPathFilters(channel);
nSlot = 0;
[offset,~] = nrPerfectTimingEstimate(pathGains,pathFilters);
hest = nrPerfectChannelEstimate(pathGains,pathFilters,NRB,SCS,nSlot,offset,sampleTimes);

% Create LDPC encoder and decoder objects
numTx = 1;
numRx = 1;
ldpcEnc = comm.LDPCEncoder;
ldpcDec = comm.LDPCDecoder;
numCodewordsPerFrame = 4;
codewordLen = size(ldpcEnc.ParityCheckMatrix, 2);

% Parameters for QAM modulation per subcarrier
bitsPerCarrier = 6;
modOrder = 2^bitsPerCarrier;
codeRate = size(ldpcEnc.ParityCheckMatrix, 1)/size(ldpcEnc.ParityCheckMatrix, 2);

% Create OFDM modulator and demodulator objects 
fftLen = 256; 
cpLen = fftLen/4; 
numGuardBandCarriers = [9; 8];
pilotCarrierIdx = [19:10:119, 139:10:239]';
numDataCarriers = fftLen - sum(numGuardBandCarriers) - length(pilotCarrierIdx) - 1;
numOFDMSymbols = numCodewordsPerFrame*codewordLen/bitsPerCarrier/numDataCarriers/numTx;
ofdmMod = comm.OFDMModulator( ...
    "FFTLength", fftLen, ....
    "NumGuardBandCarriers", numGuardBandCarriers, ...
    "InsertDCNull", true, ...
    "PilotInputPort", true, ...
    "PilotCarrierIndices", pilotCarrierIdx, ...
    "CyclicPrefixLength", cpLen, ...
    "NumSymbols", numOFDMSymbols, ...
    "NumTransmitAntennas", numTx);
ofdmDemod = comm.OFDMDemodulator(ofdmMod);
ofdmDemod.NumReceiveAntennas = numRx;


figure('name','Channel Magnitude Response Image'),
filename=['C:\work\FL_channelest\ChannelImages\',num2str(numrt),'.png'];
%surf(pow2db(abs(hest(:,:,1,1)).^2));
surface(pow2db(abs(hest(:,:,1,1)).^2));
colorbar
shading('flat');
xlabel('OFDM Symbols');ylabel('Subcarriers');zlabel('Magnitude Squared (dB)');
title('Channel Magnitude Response (1^{st} tx - 1^{st} rx antenna)');
saveas(gcf,filename)
close(viewer)

